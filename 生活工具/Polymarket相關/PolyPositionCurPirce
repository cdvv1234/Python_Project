import tkinter as tk
from tkinter import messagebox, scrolledtext
import requests
import threading
import time
import json
from datetime import datetime
import pystray
from PIL import Image, ImageDraw
import os

# ================= ğŸ”‘ é‡‘é‘°è¨­å®šå€ =================

# --- 1. LINE è¨­å®š ---
LINE_ACCESS_TOKEN = 
LINE_USER_ID = 
LINE_LIMIT_THRESHOLD = 

# --- 2. Telegram è¨­å®š ---
TELEGRAM_BOT_TOKEN = 
TELEGRAM_CHAT_ID = 

# --- 3. éŒ¢åŒ…è¨­å®š ---
DEFAULT_WALLET = 
# =========================================================

class PolyMonitorApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Polymarket ç›£æ§ V14 (è³ ç‡æ¨™ç±¤å„ªåŒ–ç‰ˆ)")
        self.root.geometry("580x850")
        
        self.is_running = False
        self.is_paused = False
        self.monitor_thread = None
        self.notified_markets = set()
        self.wallet_address = DEFAULT_WALLET
        self.line_current_usage = 0 
        
        self.root.protocol('WM_DELETE_WINDOW', self.minimize_to_tray)
        self.create_widgets()
        self.init_system_check()

    def create_widgets(self):
        # --- 1. éŒ¢åŒ…åœ°å€ ---
        tk.Label(self.root, text="ç›£æ§éŒ¢åŒ…åœ°å€:", font=("Arial", 10, "bold")).pack(pady=(10, 0))
        self.lbl_wallet = tk.Entry(self.root, width=65)
        self.lbl_wallet.insert(0, self.wallet_address)
        self.lbl_wallet.config(state='readonly')
        self.lbl_wallet.pack(pady=5)

        # --- 2. çµ•å°ç›®æ¨™åƒ¹ ---
        frame_target = tk.Frame(self.root)
        frame_target.pack(pady=5)
        tk.Label(frame_target, text="ğŸ¯ çµ•å°ç›®æ¨™åƒ¹ (Â¢):", font=("Arial", 10, "bold")).pack(side=tk.LEFT)
        self.entry_target_price = tk.Entry(frame_target, width=8, font=("Arial", 10))
        self.entry_target_price.insert(0, "0.85")
        self.entry_target_price.pack(side=tk.LEFT, padx=5)
        tk.Label(frame_target, text="(é”æ­¤åƒ¹ä½å¿…é€šçŸ¥)", fg="gray").pack(side=tk.LEFT)

        # --- 3. ç­–ç•¥åƒæ•¸è¨­å®šå€ ---
        group_strategy = tk.LabelFrame(self.root, text="ğŸ“Š ç­–ç•¥åƒæ•¸è¨­å®š (è«‹è¼¸å…¥ç™¾åˆ†æ¯” %)", padx=10, pady=10, font=("Arial", 10, "bold"), fg="#333")
        group_strategy.pack(pady=10, padx=10, fill="x")

        # è¡¨é ­
        tk.Label(group_strategy, text="ç­–ç•¥é¡å‹", width=15, anchor="w", font=("Arial", 9, "bold")).grid(row=0, column=0)
        tk.Label(group_strategy, text="ç¬¬ä¸€éšç²åˆ©", width=10, fg="green", font=("Arial", 9, "bold")).grid(row=0, column=1)
        tk.Label(group_strategy, text="ç¬¬äºŒéšç²åˆ©", width=10, fg="darkgreen", font=("Arial", 9, "bold")).grid(row=0, column=2)
        tk.Label(group_strategy, text="æ­¢æè­¦å ±", width=10, fg="red", font=("Arial", 9, "bold")).grid(row=0, column=3)

        # [A] é«˜è³ ç‡
        tk.Label(group_strategy, text="é«˜è³  (æˆæœ¬<0.4)", anchor="w").grid(row=1, column=0, pady=5)
        self.e_high_p1 = tk.Entry(group_strategy, width=8); self.e_high_p1.insert(0, "80")
        self.e_high_p1.grid(row=1, column=1)
        self.e_high_p2 = tk.Entry(group_strategy, width=8); self.e_high_p2.insert(0, "150")
        self.e_high_p2.grid(row=1, column=2)
        self.e_high_loss = tk.Entry(group_strategy, width=8); self.e_high_loss.insert(0, "-40")
        self.e_high_loss.grid(row=1, column=3)

        # [B] ä¸­è³ ç‡
        tk.Label(group_strategy, text="ä¸­è³  (0.4~0.7)", anchor="w").grid(row=2, column=0, pady=5)
        self.e_mid_p1 = tk.Entry(group_strategy, width=8); self.e_mid_p1.insert(0, "40")
        self.e_mid_p1.grid(row=2, column=1)
        self.e_mid_p2 = tk.Entry(group_strategy, width=8); self.e_mid_p2.insert(0, "80")
        self.e_mid_p2.grid(row=2, column=2)
        self.e_mid_loss = tk.Entry(group_strategy, width=8); self.e_mid_loss.insert(0, "-25")
        self.e_mid_loss.grid(row=2, column=3)

        # [C] ä½è³ ç‡
        tk.Label(group_strategy, text="ä½è³  (æˆæœ¬>0.7)", anchor="w").grid(row=3, column=0, pady=5)
        self.e_low_p1 = tk.Entry(group_strategy, width=8); self.e_low_p1.insert(0, "15")
        self.e_low_p1.grid(row=3, column=1)
        self.e_low_p2 = tk.Entry(group_strategy, width=8); self.e_low_p2.insert(0, "25")
        self.e_low_p2.grid(row=3, column=2)
        self.e_low_loss = tk.Entry(group_strategy, width=8); self.e_low_loss.insert(0, "-15")
        self.e_low_loss.grid(row=3, column=3)

        # --- 4. æŒ‰éˆ•å€ ---
        frame_btns = tk.Frame(self.root)
        frame_btns.pack(pady=10)

        self.btn_start = tk.Button(frame_btns, text="â–¶ é–‹å§‹ç›£æ§", bg="#90EE90", width=12, height=2, command=self.start_monitoring)
        self.btn_start.pack(side=tk.LEFT, padx=5)

        self.btn_pause = tk.Button(frame_btns, text="â¸ æš«åœ", state=tk.DISABLED, width=10, height=2, command=self.toggle_pause)
        self.btn_pause.pack(side=tk.LEFT, padx=5)

        self.btn_reload = tk.Button(frame_btns, text="ğŸ”„ é‡æ–°è®€å–\n(å¥—ç”¨æ–°è¨­å®š)", width=12, height=2, command=self.reload_positions)
        self.btn_reload.pack(side=tk.LEFT, padx=5)

        # --- 5. ç‹€æ…‹èˆ‡æ—¥èªŒ ---
        self.lbl_status = tk.Label(self.root, text="ç‹€æ…‹: ç³»çµ±æª¢æŸ¥ä¸­...", fg="gray")
        self.lbl_status.pack(pady=5)

        self.log_area = scrolledtext.ScrolledText(self.root, height=16)
        self.log_area.pack(padx=10, pady=5, fill=tk.BOTH, expand=True)

    def log(self, msg):
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.log_area.insert(tk.END, f"[{timestamp}] {msg}\n")
        self.log_area.see(tk.END)

    # ================= ç¶²è·¯ç™¼é€é‚è¼¯ =================

    def init_system_check(self):
        def _check():
            self.log("ğŸ” æ­£åœ¨æª¢æŸ¥é€šè¨Šç‹€æ…‹...")
            try:
                url_tg = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/getMe"
                r = requests.get(url_tg, timeout=5)
                if r.status_code == 200:
                    bot_name = r.json().get('result', {}).get('first_name')
                    self.root.after(0, lambda: self.log(f"âœ… TG é€£ç·šæˆåŠŸ (æ©Ÿå™¨äºº: {bot_name})"))
                else:
                    self.root.after(0, lambda: self.log("âŒ TG é€£ç·šç•°å¸¸"))
            except:
                self.root.after(0, lambda: self.log("âŒ TG ç„¡æ³•é€£ç·š"))

            try:
                url_line = "https://api.line.me/v2/bot/message/quota/consumption"
                headers = {"Authorization": f"Bearer {LINE_ACCESS_TOKEN}"}
                r = requests.get(url_line, headers=headers)
                if r.status_code == 200:
                    usage = r.json().get('totalUsage', 0)
                    self.line_current_usage = usage
                    msg = f"âœ… LINE é¡åº¦: {usage} / 200"
                    if usage >= LINE_LIMIT_THRESHOLD: msg += " (å·²æš«åœç™¼é€)"
                    self.root.after(0, lambda: self.log(msg))
                else:
                    self.root.after(0, lambda: self.log(f"âŒ LINE é¡åº¦è®€å–å¤±æ•—"))
            except:
                self.root.after(0, lambda: self.log("âŒ LINE ç„¡æ³•é€£ç·š"))
            
            self.root.after(0, lambda: self.lbl_status.config(text="ç‹€æ…‹: å¾…æ©Ÿä¸­"))
        threading.Thread(target=_check).start()

    def send_notification(self, text):
        # 1. ç™¼ TG
        def _send_tg():
            try:
                url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
                params = {"chat_id": TELEGRAM_CHAT_ID, "text": text}
                requests.get(url, params=params, timeout=5)
            except: pass
        threading.Thread(target=_send_tg).start()
        
        # é¡¯ç¤ºåœ¨ä»‹é¢
        self.log(f"ğŸ“¤ ç™¼é€é€šçŸ¥:\n{text.splitlines()[0]}...") 

        # 2. ç™¼ LINE (æª¢æŸ¥é¡åº¦)
        if self.line_current_usage < LINE_LIMIT_THRESHOLD:
            def _send_line():
                try:
                    url = "https://api.line.me/v2/bot/message/push"
                    headers = {"Content-Type": "application/json", "Authorization": f"Bearer {LINE_ACCESS_TOKEN}"}
                    payload = {"to": LINE_USER_ID, "messages": [{"type": "text", "text": text}]}
                    requests.post(url, headers=headers, data=json.dumps(payload))
                    self.line_current_usage += 1
                except: pass
            threading.Thread(target=_send_line).start()

    # ================= æ ¸å¿ƒé‚è¼¯ =================

    def get_filtered_positions(self):
        url = "https://data-api.polymarket.com/positions"
        params = {"user": self.wallet_address, "limit": "100", "sortBy": "TOKENS", "sortDirection": "DESC"}
        try:
            r = requests.get(url, params=params, timeout=10)
            if r.status_code == 200:
                data = r.json()
                valid_list = []
                for pos in data:
                    is_redeemable = pos.get("redeemable")
                    if is_redeemable is False or str(is_redeemable).lower() == "false":
                        if float(pos.get("size", 0)) > 0.1: valid_list.append(pos)
                return valid_list
            return []
        except: return []

    def get_strategy_params(self):
        try:
            return {
                "high": {"p1": float(self.e_high_p1.get())/100, "p2": float(self.e_high_p2.get())/100, "loss": float(self.e_high_loss.get())/100},
                "mid": {"p1": float(self.e_mid_p1.get())/100, "p2": float(self.e_mid_p2.get())/100, "loss": float(self.e_mid_loss.get())/100},
                "low": {"p1": float(self.e_low_p1.get())/100, "p2": float(self.e_low_p2.get())/100, "loss": float(self.e_low_loss.get())/100},
                "target": float(self.entry_target_price.get())
            }
        except: return None

    def start_monitoring(self):
        if self.is_running: return
        if self.get_strategy_params() is None:
            messagebox.showerror("éŒ¯èª¤", "è¨­å®šè«‹è¼¸å…¥æ•¸å­—")
            return
        self.is_running = True
        self.is_paused = False
        self.btn_start.config(state=tk.DISABLED, text="ç›£æ§ä¸­...")
        self.btn_pause.config(state=tk.NORMAL, text="â¸ æš«åœ")
        self.monitor_thread = threading.Thread(target=self.run_loop, daemon=True)
        self.monitor_thread.start()

    def toggle_pause(self):
        if self.is_paused:
            self.is_paused = False
            self.btn_pause.config(text="â¸ æš«åœ", bg="SystemButtonFace")
            self.lbl_status.config(text=f"ğŸŸ¢ ç›£æ§ä¸­", fg="green")
        else:
            self.is_paused = True
            self.btn_pause.config(text="â–¶ ç¹¼çºŒ", bg="yellow")
            self.lbl_status.config(text="ğŸŸ  å·²æš«åœ", fg="orange")

    def reload_positions(self):
        self.notified_markets.clear()
        if not self.is_running: self.start_monitoring()
        else: threading.Thread(target=self.send_initial_report, daemon=True).start()

    def calculate_stats(self, pos):
        """å…±ç”¨è¨ˆç®—é‚è¼¯ï¼šå€æ•¸"""
        avg = float(pos.get('avgPrice', 0))
        cur = float(pos.get('curPrice', 0) or pos.get('currentPrice', 0))
        
        # 1. ROI
        roi = (cur - avg) / avg if avg > 0 else 0
        
        # 2. è³‡ç”¢å€æ•¸
        multiple = cur / avg if avg > 0 else 0
        
        # 3. åŸå§‹è³ ç‡ (è²·å…¥ç•¶ä¸‹çš„è³ ç‡)
        odds_cost = round(1/avg, 2) if avg > 0 else 0
        
        return avg, cur, roi, multiple, odds_cost

    def format_line_msg(self, pos):
        """æ ¼å¼åŒ–å–®è¡Œè¨Šæ¯"""
        title = pos.get('title', pos.get('market', {}).get('question', 'æœªçŸ¥é¡Œç›®'))
        display_title = title[:40] + ("..." if len(title) > 40 else "")
        
        avg, cur, roi, multi, odds_cost = self.calculate_stats(pos)
        
        # åˆ¤æ–·ç­–ç•¥èˆ‡æ¨™ç±¤
        stype = "ä¸­è³ "
        if avg < 0.4: stype = "é«˜è³ "
        elif avg > 0.7: stype = "ä½è³ "
        
        # çµ„åˆæ¨™ç±¤: [é«˜è³  4.54]
        tag_str = f"[{stype} {odds_cost}]"
        
        # æ±ºå®šåœ–ç¤º: >=1 ç‚º ğŸ’°, <1 ç‚º ğŸ’¸
        icon = "ğŸ’°" if multi >= 1.0 else "ğŸ’¸"
        
        # çµ„åˆè¨Šæ¯
        line = (
            f"ğŸ”¹{tag_str} {display_title}\n"
            f"   æˆæœ¬:{avg:.2f} â¡ï¸ ç¾åƒ¹:{cur:.2f} ({roi*100:+.0f}%)\n"
            f"   {icon} ç•¶å‰å€æ•¸: {multi:.2f}x\n" # æœ€å¾ŒåŠ \nè£½é€ ç©ºè¡Œ
        )
        return line

    def send_initial_report(self):
        positions = self.get_filtered_positions()
        msg_lines = [f"ğŸ“‹ ã€ç›£æ§é–‹å§‹ã€‘(LINE: {self.line_current_usage}/200)\n"]
        
        if not positions:
            msg_lines.append("âš ï¸ ç›®å‰ç„¡é€²è¡Œä¸­æŒå€‰")
        else:
            for pos in positions:
                line = self.format_line_msg(pos)
                msg_lines.append(line)
        self.send_notification("\n".join(msg_lines))

    def run_loop(self):
        self.send_initial_report()

        while self.is_running:
            if not self.is_paused:
                params = self.get_strategy_params()
                if not params:
                    time.sleep(5); continue

                positions = self.get_filtered_positions()
                if positions:
                    self.root.after(0, lambda: self.lbl_status.config(text=f"ğŸŸ¢ ç›£æ§ä¸­ ({len(positions)} ç­†) LINE:{self.line_current_usage}"))
                    
                    for pos in positions:
                        try:
                            unique_id = pos.get('asset')
                            avg_price, cur_price, roi, multiple, odds_cost = self.calculate_stats(pos)
                            if avg_price <= 0: continue
                            
                            # è¨Šæ¯å…§æ–‡ (å¾©ç”¨æ ¼å¼åŒ–å‡½å¼)
                            info_msg = self.format_line_msg(pos)

                            # ç­–ç•¥åˆ†ç´š
                            p1, p2, loss_limit = 0, 0, 0
                            strategy_name = ""
                            if avg_price < 0.40:
                                strategy_name = "é«˜è³ "
                                p1=params['high']['p1']; p2=params['high']['p2']; loss_limit=params['high']['loss']
                            elif avg_price > 0.70:
                                strategy_name = "ä½è³ "
                                p1=params['low']['p1']; p2=params['low']['p2']; loss_limit=params['low']['loss']
                            else:
                                strategy_name = "ä¸­è³ "
                                p1=params['mid']['p1']; p2=params['mid']['p2']; loss_limit=params['mid']['loss']

                            # è§¸ç™¼åˆ¤æ–·
                            msg = ""
                            log_prefix = ""
                            notif_tag = ""

                            # (1) ç›®æ¨™åƒ¹é”æ¨™
                            if cur_price >= params['target']:
                                notif_tag = "target_hit"
                                if f"{unique_id}_{notif_tag}" not in self.notified_markets:
                                    log_prefix = "ğŸ¯ [ç›®æ¨™é”æ¨™]"
                                    msg = f"{log_prefix}\n{info_msg}"
                                    self.notified_markets.add(f"{unique_id}_{notif_tag}")

                            # (2) ç¬¬äºŒéšç²åˆ©
                            elif roi >= p2:
                                notif_tag = "roi_high"
                                if f"{unique_id}_{notif_tag}" not in self.notified_markets:
                                    log_prefix = f"ğŸ”¥ [å¤§è³º-{strategy_name}]"
                                    msg = f"{log_prefix} (é”æª»{p2*100:.0f}%)\n{info_msg}"
                                    self.notified_markets.add(f"{unique_id}_{notif_tag}")

                            # (3) ç¬¬ä¸€éšç²åˆ©
                            elif roi >= p1:
                                notif_tag = "roi_low"
                                if f"{unique_id}_{notif_tag}" not in self.notified_markets:
                                    log_prefix = f"ğŸŸ¢ [ç²åˆ©-{strategy_name}]"
                                    msg = f"{log_prefix} (é”æª»{p1*100:.0f}%)\n{info_msg}"
                                    self.notified_markets.add(f"{unique_id}_{notif_tag}")

                            # (4) æ­¢æ
                            elif roi <= loss_limit:
                                notif_tag = "stop_loss"
                                if f"{unique_id}_{notif_tag}" not in self.notified_markets:
                                    log_prefix = "âš ï¸ [æ­¢æè­¦å ±]"
                                    msg = f"{log_prefix} (è§¸ç™¼{loss_limit*100:.0f}%)\n{info_msg}"
                                    self.notified_markets.add(f"{unique_id}_{notif_tag}")

                            if msg:
                                self.send_notification(msg)

                        except Exception as e:
                            print(e)
                else:
                    self.root.after(0, lambda: self.lbl_status.config(text="âšª æš«ç„¡é€²è¡Œä¸­æŒå€‰"))

            for _ in range(10): 
                if not self.is_running: break
                time.sleep(1)

    def minimize_to_tray(self):
        self.root.withdraw()
        image = Image.new('RGB', (64, 64), color=(255, 255, 255))
        dc = ImageDraw.Draw(image)
        dc.ellipse((10, 10, 54, 54), fill="blue")
        menu = pystray.Menu(pystray.MenuItem('é¡¯ç¤ºè¦–çª—', self.show_window), pystray.MenuItem('çµæŸç¨‹å¼', self.quit_app))
        self.icon = pystray.Icon("PolyMonitor", image, "Polymarket ç›£æ§ä¸­", menu)
        threading.Thread(target=self.icon.run, daemon=True).start()

    def show_window(self, icon, item):
        self.icon.stop()
        self.root.after(0, self.root.deiconify)

    def quit_app(self, icon, item):
        self.is_running = False
        self.icon.stop()
        self.root.quit()
        os._exit(0)

if __name__ == "__main__":
    root = tk.Tk()
    app = PolyMonitorApp(root)
    root.mainloop()
